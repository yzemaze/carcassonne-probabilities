<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Permutation Analyzer</title>
<style>
    :root {
        color-scheme: light dark;
    }

    body {
        background-color: light-dark(#f4f4f4, #0c0c0c);
        font-family: sans-serif;
        font-size: 0.8em;
        color: light-dark(#333, #ccc);
        margin: 20px;
    }

    h1, h2, #footer {
        text-align: center;
        margin: 15px 0 10px 0;
    }

    .box-container {
        border-radius: 8px;
        background-color: light-dark(#fff, #333);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        display: grid;
        gap: 10px;
        margin: 0 auto 20px auto;
        padding: 15px;
        width: 90%;
        max-width: 500px;
    }

    .settings {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 5px;
    }

    fieldset {
        grid-column: 1 / -1;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 10px;
        background-color: transparent;
        margin-bottom: 5px;
    }

    legend {
        padding: 0 5px;
    }

    input, select {
        background-color: light-dark(#f9f9f9, #222);
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 1em;
        padding: 2px 5px;
        color: light-dark(#333, #ccc);
    }

    button {
        padding: 5px 10px;
        background-color: light-dark(#4CAF50, #005B04);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    button.loading {
        background: linear-gradient(to right, 
            light-dark(#4CAF50, #005B04) var(--progress, 0%), 
            light-dark(#ccc, #444) var(--progress, 0%));
        cursor: not-allowed;
        animation: pulse 1.5s infinite ease-in-out;
    }

    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.7; }
        100% { opacity: 1; }
    }

		button[disabled]:not(.loading) {
				background-color: gray;
		}

    button:hover {
        filter: brightness(110%);
    }

    .action-btn {
        border: none;
        border-radius: 4px;
        cursor: pointer;
        padding: 1px 5px;
        line-height: 24px;
        margin-left: 5px;
    }

    .add-btn {
        background-color: light-dark(#4CAF50, #005B04);
        color: white;
    }

    .remove-btn {
				position: absolute;
        top: -5px;
        right: 5px;
				padding: 0px 2px;
  			line-height: 16px;
        background-color: light-dark(#ff4d4d, #cc0000);
        border: 1px solid light-dark(#cc0000, #ff4d4d);
				color: white;
    }
		
		.remove-btn:hover {
        background-color: light-dark(#e60000, #ff6666);
    }

    .full-width {
        grid-column: 1 / -1;
        margin-top: 5px;
    }

    pre {
        background-color: light-dark(#eee, #222);
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 4px;
        max-height: 400px;
        overflow: auto;
        font-family: monospace;
        font-size: 0.8rem;
        margin: 0;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .node {
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 8px;
        margin: 8px 0;
        background-color: light-dark(#fafafa, #2a2a2a);
        position: relative;
        min-width: 0;
    }

    fieldset.node {
        margin-inline-start: 0;
        margin-inline-end: 0;
        padding-block-start: 0.35em;
        padding-inline-start: 0.75em;
        padding-inline-end: 0.75em;
        padding-block-end: 0.625em;
    }

		fieldset[data-type="before"] > .child {
				margin: 2px;
		}

		fieldset[data-type="before"] > .child > .label {
				display: inline-block;
				width: 30px;
		}

    .label {
        font-weight: bold;
        margin-right: 6px;
        color: light-dark(#555, #bbb);
    }

		#met-line {
				display: grid;
  			grid-template-columns: 13em auto;
		}

    #footer p {
        display: flex;
        justify-content: center;
        gap: 15px;
    }
    
    a {
        color: light-dark(#0066cc, #66b2ff);
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
</style>
</head>

<body>
<h1>Permutation Analyzer</h1>

<div class="box-container">
    <div class="settings">
        <label for="totalTiles">Total tiles:</label>
        <input id="totalTiles" type="number" value="71" min="2" max="71">
    </div>
    <div class="settings">
        <label for="careTiles">Specific tiles:</label>
        <input id="careTiles" value="" placeholder="a, b">
    </div>
    <div class="settings">
        <label for="sims">Simulations:</label>
        <input id="sims" type="number" value="100000" min="1000">
    </div>

    <div id="tree"></div>

    <button class="full-width" onclick="run()">Run Simulation</button>
</div>

<div id="results-section" style="display: none;">
    <h2>Results</h2>
    <div class="box-container">
        <div id="met-line"><label for="met-value">Conditions met:</label><span id="met-value"></span></div>
        <button id="list-perms-btn" onclick="listWinningPermutations()" style="margin-bottom: 5px;">List Winning Permutations</button>
        <div id="perms-container" style="display: none;">
            <div id="perms-display" style="margin-bottom: 5px;"></div>
            <pre id="perms-list"></pre>
        </div>
    </div>
</div>

<div id="footer">
    <p>
        <a href="https://github.com/yzemaze/carcassonne-probabilities">Examples, feedback, source code etc.</a>
        <span>|</span>
        <a href="./carcassonne-draw-probabilities.html">Draw Simulator</a>
    </p>
</div>
<script>
function shuffle(a) {
  for (let i=a.length-1;i>0;i--) {
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
}

function isBeforeBranch(el) {
  return el.classList.contains("before-branch")
}

function updateBeforeBranch(branch) {
  const hasNode = !!branch.querySelector(":scope > .node");

	branch.querySelectorAll(":scope > button").forEach(b => {
		b.disabled = hasNode;
	});
}

const tree = document.getElementById("tree");

function createRoot() {
  const d = document.createElement("fieldset");
  d.className = "node";
  d.dataset.type = "logic";
  d.innerHTML = `
    <legend>Logic Group</legend>
    <select class="op">
      <option>AND</option>
      <option>OR</option>
      <option>NAND</option>
      <option>NOR</option>
      <option>XOR</option>
    </select>
    <button class="action-btn add-btn" onclick="addCondition(this.parentNode)" title="Add Condition">+ Condition</button>
    <button class="action-btn add-btn" onclick="addLogic(this.parentNode)" title="Add Logic Group">+ Logic Group</button>
    <button class="action-btn add-btn" onclick="addBefore(this.parentNode)" title="Add Before">+ Before</button>
  `;
  tree.appendChild(d);
}

function addCondition(parent) {
  const d = document.createElement("fieldset");
  d.className = "node child";
  d.dataset.type = "condition";
  d.innerHTML = `
    <legend>Condition</legend>
    <button class="action-btn remove-btn" onclick="removeNode(this)" title="Remove">×</button>
    <select class="player"><option>A</option><option>B</option></select>
		draws
    <select class="quant">
      <option>at least</option>
      <option>at most</option>
      <option>exactly</option>
    </select>
    <input class="num" type="number" value="1" min="0" style="width: 40px;">
		of
    <input class="tiles" value="" placeholder="a, b" style="width: 80px;">
  `;
  parent.appendChild(d);

  if (isBeforeBranch(parent)) updateBeforeBranch(parent);
}

function addLogic(parent) {
  const d = document.createElement("fieldset");
  d.className = "node child";
  d.dataset.type = "logic";
  d.innerHTML = `
    <legend>Logic Group</legend>
    <button class="action-btn remove-btn" onclick="removeNode(this)" title="Remove">×</button>
    <select class="op">
      <option>AND</option>
      <option>OR</option>
      <option>XOR</option>
      <option>NAND</option>
      <option>NOR</option>
    </select>
    <button class="action-btn add-btn" onclick="addCondition(this.parentNode)" title="Add Condition">+ Condition</button>
    <button class="action-btn add-btn" onclick="addLogic(this.parentNode)" title="Add Logic Group">+ Logic Group</button>
    <button class="action-btn add-btn" onclick="addBefore(this.parentNode)" title="Add Before">+ Before</button>
  `;
  parent.appendChild(d);

  if (isBeforeBranch(parent)) updateBeforeBranch(parent);
}

function addBefore(parent) {
  const d = document.createElement("fieldset");
  d.className = "node child";
  d.dataset.type = "before";
  d.innerHTML = `
    <legend>Before</legend>
    <button class="action-btn remove-btn" onclick="removeNode(this)" title="Remove">×</button>

    <div class="child before-branch">
      <span class="label">1st</span>
      <button class="action-btn add-btn" onclick="addCondition(this.parentNode)" title="Add Condition">+ Condition</button>
      <button class="action-btn add-btn" onclick="addLogic(this.parentNode)" title="Add Logic Group">+ Logic Group</button>
    </div>

    <div class="child before-branch">
      <span class="label">2nd</span>
      <button class="action-btn add-btn" onclick="addCondition(this.parentNode)" title="Add Condition">+ Condition</button>
      <button class="action-btn add-btn" onclick="addLogic(this.parentNode)" title="Add Logic Group">+ Logic Group</button>
    </div>
  `;
  parent.appendChild(d);
}

function removeNode(btn) {
  const node = btn.parentNode;
  const parent = node.parentNode;
  node.remove();

  if (isBeforeBranch(parent)) {
    updateBeforeBranch(parent);
  }
}

function evalNode(node, draws) {
  const type = node.dataset.type;

  if (type === "condition") {
    const player = node.querySelector(".player").value;
    const quant = node.querySelector(".quant").value;
    const num = +node.querySelector(".num").value;
    const tiles = new Set(
      node.querySelector(".tiles").value.split(",").map(x=>x.trim()).filter(Boolean)
    );

    let count = 0;
    let firstTurn = null;

    draws.forEach((d,i)=>{
      if (d.player===player && tiles.has(d.tile)) {
        count++;
        if (firstTurn===null) firstTurn=i;
      }
    });

    let ok=false;
    if (quant==="at least") ok = count>=num;
    if (quant==="at most") ok = count<=num;
    if (quant==="exactly") ok = count===num;

    return { ok, turn:firstTurn };
  }

  if (type === "before") {
    const branches = [...node.children].filter(c => c.classList.contains("child"));
    const left = branches[0].querySelector(".node");
    const right = branches[1].querySelector(".node");

    if (!left || !right) return { ok:false };

    const a = evalNode(left,draws);
    const b = evalNode(right,draws);

    return {
      ok: a.ok && b.ok && a.turn < b.turn
    };
  }

  if (type === "logic") {
    const op = node.querySelector(".op").value;
    const kids = [...node.children].filter(x=>x.dataset?.type);
    const rs = kids.map(k=>evalNode(k,draws).ok);

    if (op==="AND") return { ok: rs.every(Boolean) };
    if (op==="OR") return { ok: rs.some(Boolean) };
    if (op==="XOR") return { ok: rs.filter(Boolean).length===1 };
    if (op==="NAND") return { ok: !rs.every(Boolean) };
    if (op==="NOR") return { ok: !rs.some(Boolean) };
  }
}

async function run() {
  const btn = document.querySelector('button.full-width');
  btn.disabled = true;
  btn.classList.add('loading');
  btn.style.setProperty('--progress', '0%');

  const total = +document.getElementById("totalTiles").value;
  const care = document.getElementById("careTiles").value.split(",").map(x=>x.trim()).filter(Boolean);
  const sims = +document.getElementById("sims").value;

  let met = 0;
  const perms = new Set();

  const chunkSize = Math.max(100, Math.floor(sims / 100));
  for (let i = 0; i < sims; i += chunkSize) {
    const end = Math.min(i + chunkSize, sims);
    for (let j = i; j < end; j++) {
      const deck=[];
      for (let k=0;k<total;k++) deck.push(care[k]||"_");
      shuffle(deck);

      const draws = deck.map((t,k)=>({ tile:t, player:k%2===0?"A":"B" }));

      if (evalNode(tree.firstElementChild,draws).ok) {
        met++;
        perms.add(deck.map(t=>care.includes(t)?t:"_").join(", "));
      }
    }
    
    const progress = (end / sims) * 100;
    btn.style.setProperty('--progress', `${progress}%`);
    await new Promise(resolve => setTimeout(resolve, 0));
  }

  document.getElementById("results-section").style.display = "block";
  document.getElementById("met-value").textContent = `${(met/sims*100).toFixed(2)}%`;
  
  document.getElementById("perms-display").textContent = `${perms.size} unique permutations`;
  document.getElementById("perms-list").textContent = [...perms].sort().join("\n");
  
  document.getElementById("list-perms-btn").style.display = "inline-block";
  document.getElementById("perms-container").style.display = "none";

  btn.disabled = false;
  btn.classList.remove('loading');
  btn.style.removeProperty('--progress');
}

function listWinningPermutations() {
    document.getElementById("list-perms-btn").style.display = "none";
    document.getElementById("perms-container").style.display = "block";
}

createRoot();
</script>
</body>
</html>
